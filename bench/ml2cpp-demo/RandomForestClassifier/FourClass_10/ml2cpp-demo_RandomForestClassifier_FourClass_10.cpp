// ******************************************************** 

// This C++ code was automatically generated by ml2cpp (development version).
// Copyright 2020

// https://github.com/antoinecarme/ml2cpp
// Model : RandomForestClassifier
// Dataset : FourClass_10

// This CPP code can be compiled using any C++-17 compiler.
// g++ -Wall -Wno-unused-function -std=c++17 -g -o ml2cpp-demo_RandomForestClassifier_FourClass_10.exe ml2cpp-demo_RandomForestClassifier_FourClass_10.cpp

// Model deployment code

// ******************************************************** 

#include "../../Generic.i"

namespace  {

	std::vector<std::any> get_classes(){
		std::vector<std::any> lClasses = { 0, 1, 2, 3 };

		return lClasses;
	}

	namespace RF_Tree_0 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 26 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 27 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 29 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 30 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 31 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 33 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 34 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.6375722885131836) ? ( (Feature_4 <= -0.7205710709095001) ? ( (Feature_1 <= -0.3766303211450577) ? ( 3 ) : ( (Feature_2 <= -2.3242909908294678) ? ( 5 ) : ( 6 ) ) ) : ( (Feature_5 <= 0.43505100905895233) ? ( (Feature_2 <= 0.6566844582557678) ? ( (Feature_3 <= -2.2284879088401794) ? ( 10 ) : ( (Feature_8 <= 0.027076072990894318) ? ( (Feature_2 <= -0.7908840589225292) ? ( 13 ) : ( 14 ) ) : ( 15 ) ) ) : ( 16 ) ) : ( 17 ) ) ) : ( (Feature_4 <= 0.5321277976036072) ? ( (Feature_6 <= -0.30175986886024475) ? ( (Feature_7 <= 1.7358007431030273) ? ( (Feature_2 <= 0.286959171295166) ? ( 22 ) : ( (Feature_0 <= 0.9448466002941132) ? ( 24 ) : ( (Feature_8 <= -2.7210813164711) ? ( 26 ) : ( 27 ) ) ) ) : ( (Feature_5 <= -0.11045998334884644) ? ( 29 ) : ( 30 ) ) ) : ( 31 ) ) : ( (Feature_1 <= -0.6816645860671997) ? ( 33 ) : ( 34 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_0
	

	namespace RF_Tree_1 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 23 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 27 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 29 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 31 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 32 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 33 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 34 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_7 <= -0.22361279278993607) ? ( (Feature_3 <= -0.697431281208992) ? ( (Feature_5 <= 0.07402315735816956) ? ( (Feature_8 <= 0.10759366862475872) ? ( 4 ) : ( 5 ) ) : ( (Feature_1 <= -0.017532378435134888) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_6 <= -0.6315318197011948) ? ( (Feature_0 <= -0.31354502215981483) ? ( 11 ) : ( 12 ) ) : ( 13 ) ) ) : ( (Feature_1 <= -0.07957301661372185) ? ( (Feature_7 <= 0.6393938362598419) ? ( (Feature_0 <= 0.10280615091323853) ? ( 17 ) : ( 18 ) ) : ( 19 ) ) : ( (Feature_8 <= 1.0354389548301697) ? ( (Feature_3 <= 0.48236972093582153) ? ( (Feature_2 <= -0.5356880724430084) ? ( 23 ) : ( 24 ) ) : ( (Feature_1 <= 2.708956480026245) ? ( (Feature_4 <= -3.0557994842529297) ? ( 27 ) : ( (Feature_2 <= 1.819919764995575) ? ( 29 ) : ( (Feature_7 <= 0.6686980426311493) ? ( 31 ) : ( 32 ) ) ) ) : ( 33 ) ) ) : ( 34 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_1
	

	namespace RF_Tree_2 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 9 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 11 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= 0.2519511356949806) ? ( (Feature_2 <= -0.5535716265439987) ? ( (Feature_0 <= 1.9504499435424805) ? ( 3 ) : ( 4 ) ) : ( (Feature_6 <= -0.6120180785655975) ? ( 6 ) : ( (Feature_7 <= 0.5543844103813171) ? ( (Feature_5 <= 0.11753926426172256) ? ( 9 ) : ( 10 ) ) : ( 11 ) ) ) ) : ( (Feature_2 <= -1.900172233581543) ? ( 13 ) : ( (Feature_7 <= 0.44504228234291077) ? ( (Feature_4 <= 0.9742768108844757) ? ( 16 ) : ( (Feature_8 <= 0.7028817236423492) ? ( 18 ) : ( 19 ) ) ) : ( (Feature_5 <= 0.32368578389286995) ? ( 21 ) : ( (Feature_8 <= 0.833812028169632) ? ( 23 ) : ( 24 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_2
	

	namespace RF_Tree_3 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 14 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 17 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 28 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 30 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 32 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 33 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 34 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.6734017729759216) ? ( (Feature_3 <= -1.7759541869163513) ? ( 2 ) : ( (Feature_2 <= -0.14206767454743385) ? ( (Feature_4 <= 0.6074020117521286) ? ( (Feature_8 <= -0.44029349088668823) ? ( (Feature_0 <= -1.3705571293830872) ? ( 7 ) : ( (Feature_0 <= 0.9705447554588318) ? ( 9 ) : ( 10 ) ) ) : ( (Feature_8 <= 1.2823887765407562) ? ( 12 ) : ( 13 ) ) ) : ( 14 ) ) : ( (Feature_2 <= 0.6566844582557678) ? ( 16 ) : ( 17 ) ) ) ) : ( (Feature_0 <= -0.39712053537368774) ? ( (Feature_6 <= -1.4627249836921692) ? ( 20 ) : ( 21 ) ) : ( (Feature_3 <= 1.6578887104988098) ? ( (Feature_5 <= 0.035379186272621155) ? ( 24 ) : ( 25 ) ) : ( (Feature_0 <= 0.9563984274864197) ? ( (Feature_9 <= -2.0291459560394287) ? ( 28 ) : ( (Feature_8 <= 0.17044619470834732) ? ( 30 ) : ( (Feature_5 <= -0.19116689264774323) ? ( 32 ) : ( 33 ) ) ) ) : ( 34 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_3
	

	namespace RF_Tree_4 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 7 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 8 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 17 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 27 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 29 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 33 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 34 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 35 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 36 ,  {0.0, 0.0, 0.0, 1.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_2 <= 1.0767131447792053) ? ( (Feature_8 <= -1.5628834962844849) ? ( 2 ) : ( (Feature_4 <= 0.5936837196350098) ? ( (Feature_1 <= 1.0470824539661407) ? ( (Feature_8 <= -0.4956623911857605) ? ( (Feature_9 <= -0.4809478372335434) ? ( 7 ) : ( 8 ) ) : ( (Feature_8 <= 1.1345493793487549) ? ( (Feature_5 <= 0.1068858876824379) ? ( (Feature_7 <= -2.736905187368393) ? ( 12 ) : ( 13 ) ) : ( 14 ) ) : ( (Feature_1 <= 0.325680248439312) ? ( 16 ) : ( 17 ) ) ) ) : ( (Feature_7 <= 1.7900195121765137) ? ( (Feature_0 <= -0.7842139303684235) ? ( 20 ) : ( (Feature_8 <= -1.2063674628734589) ? ( 22 ) : ( 23 ) ) ) : ( 24 ) ) ) : ( (Feature_3 <= 0.5939029157161713) ? ( (Feature_6 <= 1.1597294807434082) ? ( 27 ) : ( 28 ) ) : ( 29 ) ) ) ) : ( (Feature_1 <= 2.4217634201049805) ? ( (Feature_1 <= -0.6816645860671997) ? ( (Feature_2 <= 2.918387293815613) ? ( 33 ) : ( 34 ) ) : ( 35 ) ) : ( 36 ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_4
	

	namespace RF_Tree_5 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 10 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 13 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 15 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 29 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 31 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 32 ,  {1.0, 0.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_7 <= 0.362348735332489) ? ( (Feature_8 <= 1.8644729852676392) ? ( (Feature_3 <= -0.697431281208992) ? ( (Feature_8 <= -0.44029349088668823) ? ( 4 ) : ( (Feature_2 <= -0.4794807583093643) ? ( 6 ) : ( 7 ) ) ) : ( (Feature_5 <= 1.0204831063747406) ? ( (Feature_7 <= -0.20112159848213196) ? ( 10 ) : ( (Feature_9 <= 0.47289878129959106) ? ( 12 ) : ( 13 ) ) ) : ( (Feature_7 <= -0.6858490109443665) ? ( 15 ) : ( 16 ) ) ) ) : ( 17 ) ) : ( (Feature_6 <= -0.47018319368362427) ? ( (Feature_8 <= -1.0184336304664612) ? ( 20 ) : ( (Feature_6 <= -0.9379337430000305) ? ( (Feature_6 <= -2.3284720182418823) ? ( 23 ) : ( (Feature_4 <= 1.2688489109277725) ? ( 25 ) : ( 26 ) ) ) : ( (Feature_7 <= 1.015733689069748) ? ( 28 ) : ( 29 ) ) ) ) : ( (Feature_2 <= -1.680073618888855) ? ( 31 ) : ( 32 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_5
	

	namespace RF_Tree_6 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 4 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 7 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 8 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 24 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 27 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 29 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 34 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 36 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 37 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 38 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 39 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 40 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_6 <= -0.43793630599975586) ? ( (Feature_7 <= 0.4184545576572418) ? ( (Feature_1 <= -0.5951647609472275) ? ( 3 ) : ( 4 ) ) : ( (Feature_1 <= -0.12893121317029) ? ( (Feature_0 <= -0.3492945656180382) ? ( 7 ) : ( 8 ) ) : ( (Feature_0 <= 0.3975365161895752) ? ( (Feature_8 <= 0.33265136182308197) ? ( 11 ) : ( (Feature_2 <= 1.105999916791916) ? ( 13 ) : ( 14 ) ) ) : ( (Feature_6 <= -0.5858463048934937) ? ( (Feature_7 <= 3.2054656744003296) ? ( 17 ) : ( 18 ) ) : ( 19 ) ) ) ) ) : ( (Feature_4 <= -0.7161647081375122) ? ( (Feature_6 <= 0.86536505818367) ? ( (Feature_5 <= 0.6994040310382843) ? ( (Feature_6 <= 0.12385182082653046) ? ( 24 ) : ( 25 ) ) : ( (Feature_6 <= -0.025426294188946486) ? ( 27 ) : ( 28 ) ) ) : ( 29 ) ) : ( (Feature_3 <= 0.6257461905479431) ? ( (Feature_2 <= 0.5876395106315613) ? ( (Feature_6 <= 1.0931134819984436) ? ( (Feature_5 <= 0.26575564593076706) ? ( 34 ) : ( (Feature_6 <= -0.21960283070802689) ? ( 36 ) : ( 37 ) ) ) : ( 38 ) ) : ( 39 ) ) : ( 40 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_6
	

	namespace RF_Tree_7 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 8 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 22 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 27 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 0.0, 0.0, 1.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= 0.2519511356949806) ? ( (Feature_3 <= -1.5270347595214844) ? ( 2 ) : ( (Feature_3 <= 1.5462548732757568) ? ( (Feature_5 <= 0.17443424463272095) ? ( 5 ) : ( (Feature_4 <= -0.2997691296041012) ? ( (Feature_9 <= 0.08598099648952484) ? ( 8 ) : ( 9 ) ) : ( 10 ) ) ) : ( 11 ) ) ) : ( (Feature_2 <= -1.900172233581543) ? ( 13 ) : ( (Feature_4 <= -0.13157445192337036) ? ( (Feature_3 <= 1.4394111037254333) ? ( 16 ) : ( (Feature_3 <= 5.079064846038818) ? ( (Feature_2 <= 0.3941776491701603) ? ( (Feature_2 <= -0.1725896019488573) ? ( 20 ) : ( 21 ) ) : ( 22 ) ) : ( 23 ) ) ) : ( (Feature_2 <= -0.9964120984077454) ? ( 25 ) : ( (Feature_3 <= 4.148848652839661) ? ( 27 ) : ( 28 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_7
	

	namespace RF_Tree_8 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 5 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 24 ,  {1.0, 0.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_7 <= 0.5650001168251038) ? ( (Feature_6 <= -0.2524780109524727) ? ( (Feature_3 <= 1.9839490056037903) ? ( (Feature_3 <= 1.4057671427726746) ? ( 4 ) : ( 5 ) ) : ( 6 ) ) : ( (Feature_1 <= 0.37201856821775436) ? ( (Feature_8 <= 1.4978562891483307) ? ( 9 ) : ( 10 ) ) : ( (Feature_8 <= 0.26736992970108986) ? ( (Feature_4 <= 0.3258809447288513) ? ( 13 ) : ( 14 ) ) : ( 15 ) ) ) ) : ( (Feature_6 <= -0.47018319368362427) ? ( (Feature_3 <= 3.997441053390503) ? ( 18 ) : ( (Feature_6 <= -2.223681092262268) ? ( 20 ) : ( 21 ) ) ) : ( (Feature_2 <= -1.680073618888855) ? ( 23 ) : ( 24 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_8
	

	namespace RF_Tree_9 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 5 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 25 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 29 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 30 ,  {0.0, 0.0, 0.0, 1.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= -0.11360954865813255) ? ( (Feature_6 <= 0.7429802119731903) ? ( (Feature_5 <= 0.5384753793478012) ? ( (Feature_2 <= 1.4471147954463959) ? ( 4 ) : ( 5 ) ) : ( 6 ) ) : ( 7 ) ) : ( (Feature_1 <= 1.6609216332435608) ? ( (Feature_3 <= 1.0702359676361084) ? ( (Feature_0 <= 0.6615244448184967) ? ( (Feature_2 <= -1.900172233581543) ? ( 12 ) : ( (Feature_7 <= -0.09691016376018524) ? ( 14 ) : ( 15 ) ) ) : ( 16 ) ) : ( (Feature_4 <= -1.3972975015640259) ? ( (Feature_8 <= -0.29086214303970337) ? ( 19 ) : ( 20 ) ) : ( 21 ) ) ) : ( (Feature_7 <= 0.44504228234291077) ? ( (Feature_8 <= 2.3080238103866577) ? ( 24 ) : ( 25 ) ) : ( (Feature_9 <= 0.48277218639850616) ? ( (Feature_4 <= -1.5992228388786316) ? ( 28 ) : ( 29 ) ) : ( 30 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_9
	

	namespace RF_Tree_10 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 6 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 17 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 23 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 25 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 29 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 31 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 33 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 34 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= -0.18501364439725876) ? ( (Feature_2 <= -0.47586841881275177) ? ( (Feature_7 <= -0.30184680223464966) ? ( 3 ) : ( (Feature_9 <= 0.48823489248752594) ? ( 5 ) : ( 6 ) ) ) : ( (Feature_3 <= -2.3578283190727234) ? ( 8 ) : ( (Feature_2 <= 2.4494805335998535) ? ( 10 ) : ( 11 ) ) ) ) : ( (Feature_7 <= 0.362348735332489) ? ( (Feature_8 <= 0.6027734875679016) ? ( (Feature_5 <= -1.2919885516166687) ? ( (Feature_3 <= -0.7561548203229904) ? ( 16 ) : ( 17 ) ) : ( 18 ) ) : ( (Feature_6 <= -0.4988042116165161) ? ( 20 ) : ( (Feature_1 <= 1.5552623271942139) ? ( (Feature_3 <= -0.24176281690597534) ? ( 23 ) : ( 24 ) ) : ( 25 ) ) ) ) : ( (Feature_9 <= 0.0133257657289505) ? ( (Feature_5 <= 0.9273337721824646) ? ( 28 ) : ( 29 ) ) : ( (Feature_8 <= -0.7475364357233047) ? ( 31 ) : ( (Feature_7 <= 0.6157610416412354) ? ( 33 ) : ( 34 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_10
	

	namespace RF_Tree_11 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 1 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 4 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 26 ,  {1.0, 0.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= -1.9042950868606567) ? ( 1 ) : ( (Feature_1 <= 0.00490424782037735) ? ( (Feature_6 <= -0.8221747577190399) ? ( 4 ) : ( (Feature_4 <= -1.9389472603797913) ? ( 6 ) : ( 7 ) ) ) : ( (Feature_4 <= -0.13157445192337036) ? ( (Feature_6 <= -1.39120352268219) ? ( (Feature_7 <= 0.648763433098793) ? ( 11 ) : ( 12 ) ) : ( (Feature_0 <= -0.8877669870853424) ? ( 14 ) : ( (Feature_0 <= 0.3413665294647217) ? ( 16 ) : ( (Feature_8 <= -1.3938634395599365) ? ( 18 ) : ( (Feature_2 <= 0.2748861387372017) ? ( 20 ) : ( 21 ) ) ) ) ) ) : ( (Feature_1 <= 1.4476115107536316) ? ( 23 ) : ( (Feature_8 <= 0.22102762013673782) ? ( 25 ) : ( 26 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_11
	

	namespace RF_Tree_12 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 5 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 6 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 18 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 22 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 27 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 29 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 30 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_7 <= 0.362348735332489) ? ( (Feature_6 <= 0.12630898132920265) ? ( (Feature_6 <= -0.3437446802854538) ? ( 3 ) : ( (Feature_7 <= -0.4222462549805641) ? ( 5 ) : ( 6 ) ) ) : ( (Feature_3 <= -1.7722215056419373) ? ( 8 ) : ( (Feature_6 <= 0.29790325462818146) ? ( 10 ) : ( (Feature_1 <= 1.205538421869278) ? ( (Feature_9 <= 0.7542566657066345) ? ( 13 ) : ( 14 ) ) : ( 15 ) ) ) ) ) : ( (Feature_5 <= -0.4089828282594681) ? ( (Feature_1 <= -0.3682653605937958) ? ( 18 ) : ( (Feature_2 <= 0.18018071725964546) ? ( (Feature_6 <= -1.3004269301891327) ? ( 21 ) : ( 22 ) ) : ( 23 ) ) ) : ( (Feature_0 <= -1.9673755764961243) ? ( 25 ) : ( (Feature_3 <= 1.5132884979248047) ? ( 27 ) : ( (Feature_8 <= 1.0397457480430603) ? ( 29 ) : ( 30 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_12
	

	namespace RF_Tree_13 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 7 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 13 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 17 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 26 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 27 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 28 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 30 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 31 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 34 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 35 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 38 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 39 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 40 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_6 <= -0.43784700334072113) ? ( (Feature_7 <= 0.362348735332489) ? ( 2 ) : ( (Feature_7 <= 3.071837544441223) ? ( (Feature_9 <= 0.5913583934307098) ? ( (Feature_4 <= 0.7092837691307068) ? ( (Feature_5 <= 1.7956550121307373) ? ( 7 ) : ( 8 ) ) : ( (Feature_9 <= -0.9979718253016472) ? ( 10 ) : ( 11 ) ) ) : ( (Feature_3 <= 1.3834297060966492) ? ( 13 ) : ( (Feature_3 <= 2.7110737562179565) ? ( (Feature_4 <= -1.2375476360321045) ? ( 16 ) : ( 17 ) ) : ( 18 ) ) ) ) : ( 19 ) ) ) : ( (Feature_4 <= -0.38003355264663696) ? ( (Feature_5 <= 0.44713953137397766) ? ( (Feature_9 <= 2.1687114238739014) ? ( (Feature_0 <= 0.1700249221175909) ? ( (Feature_1 <= 0.6940511912107468) ? ( 25 ) : ( 26 ) ) : ( 27 ) ) : ( 28 ) ) : ( (Feature_0 <= -1.3705571293830872) ? ( 30 ) : ( 31 ) ) ) : ( (Feature_1 <= -0.9786497056484222) ? ( (Feature_8 <= 1.4049836695194244) ? ( 34 ) : ( 35 ) ) : ( (Feature_5 <= 0.25930869206786156) ? ( (Feature_3 <= 0.5939029157161713) ? ( 38 ) : ( 39 ) ) : ( 40 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_13
	

	namespace RF_Tree_14 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 15 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 30 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 31 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 33 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 34 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.6454985737800598) ? ( (Feature_3 <= -1.7759541869163513) ? ( 2 ) : ( (Feature_5 <= 0.9047573208808899) ? ( (Feature_7 <= 2.124562382698059) ? ( (Feature_2 <= 0.5715263187885284) ? ( (Feature_9 <= -0.1060999371111393) ? ( 7 ) : ( (Feature_9 <= 0.3257526606321335) ? ( 9 ) : ( 10 ) ) ) : ( 11 ) ) : ( 12 ) ) : ( (Feature_7 <= 0.4125555157661438) ? ( 14 ) : ( 15 ) ) ) ) : ( (Feature_8 <= 1.0354389548301697) ? ( (Feature_7 <= -0.32661987096071243) ? ( (Feature_2 <= 2.3217922151088715) ? ( 19 ) : ( 20 ) ) : ( (Feature_3 <= 1.5132884979248047) ? ( (Feature_2 <= 0.6083518684026785) ? ( 23 ) : ( 24 ) ) : ( (Feature_9 <= 0.22027607262134552) ? ( 26 ) : ( (Feature_8 <= -0.2452784851193428) ? ( 28 ) : ( (Feature_3 <= 2.8667889833450317) ? ( 30 ) : ( 31 ) ) ) ) ) ) : ( (Feature_7 <= 0.6524839902995154) ? ( 33 ) : ( 34 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_14
	

	namespace RF_Tree_15 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 9 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 24 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 29 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 30 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 31 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 32 ,  {1.0, 0.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= -0.18501364439725876) ? ( (Feature_6 <= 0.25661879032850266) ? ( (Feature_6 <= -0.8221747577190399) ? ( 3 ) : ( 4 ) ) : ( (Feature_7 <= 0.3409436233341694) ? ( (Feature_1 <= -0.46346817165613174) ? ( 7 ) : ( 8 ) ) : ( 9 ) ) ) : ( (Feature_6 <= -0.30175986886024475) ? ( (Feature_7 <= 0.1897896433947608) ? ( (Feature_6 <= -0.3437446802854538) ? ( 13 ) : ( 14 ) ) : ( (Feature_5 <= 0.36262839287519455) ? ( (Feature_2 <= -0.46029795706272125) ? ( (Feature_7 <= 0.9534086287021637) ? ( 18 ) : ( 19 ) ) : ( 20 ) ) : ( (Feature_8 <= 0.7609498202800751) ? ( (Feature_6 <= -1.1888949275016785) ? ( 23 ) : ( 24 ) ) : ( 25 ) ) ) ) : ( (Feature_4 <= 0.9619536250829697) ? ( (Feature_1 <= 0.8972356617450714) ? ( (Feature_7 <= -0.9355948269367218) ? ( 29 ) : ( 30 ) ) : ( 31 ) ) : ( 32 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace RF_Tree_15
	

	std::vector<std::string> get_input_names(){
		std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };

		return lFeatures;
	}

	std::vector<std::string> get_output_names(){
		std::vector<std::string> lOutputs = { 
			"Score_0", "Score_1", "Score_2", "Score_3",
			"Proba_0", "Proba_1", "Proba_2", "Proba_3",
			"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
			"Decision", "DecisionProba" };

		return lOutputs;
	}

	tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
		auto lClasses = get_classes();

		std::vector<tTable> lTreeScores = { 
			RF_Tree_0::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_1::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_2::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_3::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_4::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_5::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_6::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_7::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_8::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_9::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_10::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_11::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_12::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_13::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_14::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			RF_Tree_15::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9)
		};

		tTable lAggregatedTable = aggregate_rf_scores(lTreeScores, {"Proba", "Score"});


		tTable lTable = lAggregatedTable;

		int lBestClass = get_arg_max( lTable["Proba"] );
		auto lDecision = lClasses[lBestClass];
		lTable["Decision"] = { lDecision } ;
		lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };

		recompute_log_probas( lTable );

		return lTable;
	}

	tTable compute_model_outputs_from_table( tTable const & iTable) {
		tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);

		return lTable;
	}

} // eof namespace 


int main() {
	score_csv_file("outputs/ml2cpp-demo/datasets/FourClass_10.csv");
	return 0;
}
