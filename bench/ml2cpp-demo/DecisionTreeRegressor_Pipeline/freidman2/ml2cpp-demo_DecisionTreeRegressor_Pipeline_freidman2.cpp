// ******************************************************** 

// This C++ code was automatically generated by ml2cpp (development version).
// Copyright 2020

// https://github.com/antoinecarme/ml2cpp
// Model : DecisionTreeRegressor_Pipeline
// Dataset : freidman2

// This CPP code can be compiled using any C++-17 compiler.
// g++ -Wall -Wno-unused-function -std=c++17 -g -o ml2cpp-demo_DecisionTreeRegressor_Pipeline_freidman2.exe ml2cpp-demo_DecisionTreeRegressor_Pipeline_freidman2.cpp

// Model deployment code

// ******************************************************** 

#include "../../Generic.i"

namespace  {

	namespace imputer {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
	
			tTable lTable;
	
			lTable["imputer_output_2"] = { ((Feature_0 == std::any()) ?  ( 43.79128122207401 ) : ( Feature_0)) };
			lTable["imputer_output_3"] = { ((Feature_1 == std::any()) ?  ( 945.9672833084396 ) : ( Feature_1)) };
			lTable["imputer_output_4"] = { ((Feature_2 == std::any()) ?  ( 0.5310009099975209 ) : ( Feature_2)) };
			lTable["imputer_output_5"] = { ((Feature_3 == std::any()) ?  ( 6.139967152050499 ) : ( Feature_3)) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);
	
			return lTable;
		}
	
	} // eof namespace imputer
	

	namespace scaler {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any imputer_output_2, std::any imputer_output_3, std::any imputer_output_4, std::any imputer_output_5) {
	
			tTable lTable;
	
			lTable["scaler_output_2"] = { ( ( imputer_output_2 - 43.79128122207401 ) / 26.03562357622511 ) };
			lTable["scaler_output_3"] = { ( ( imputer_output_3 - 945.9672833084396 ) / 461.4552766146446 ) };
			lTable["scaler_output_4"] = { ( ( imputer_output_4 - 0.5310009099975209 ) / 0.2901863282144786 ) };
			lTable["scaler_output_5"] = { ( ( imputer_output_5 - 6.139967152050499 ) / 3.072917242564058 ) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("imputer_output_2")[0], iTable.at("imputer_output_3")[0], iTable.at("imputer_output_4")[0], iTable.at("imputer_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace scaler
	

	namespace model {
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 6 ,  {42.01839185 }} ,
				{ 7 ,  {45.71113412 }} ,
				{ 8 ,  {17.5126316 }} ,
				{ 11 ,  {38.41875351 }} ,
				{ 13 ,  {60.17684929 }} ,
				{ 15 ,  {66.46875936 }} ,
				{ 16 ,  {67.61473198 }} ,
				{ 18 ,  {89.81697753 }} ,
				{ 20 ,  {74.13416807 }} ,
				{ 21 ,  {81.61991679 }} ,
				{ 25 ,  {174.68142017 }} ,
				{ 26 ,  {168.83377965 }} ,
				{ 27 ,  {154.50461473 }} ,
				{ 29 ,  {251.33228306 }} ,
				{ 32 ,  {205.37013415 }} ,
				{ 33 ,  {212.83015826 }} ,
				{ 34 ,  {222.6809715 }} ,
				{ 40 ,  {112.36813458 }} ,
				{ 42 ,  {131.74760526 }} ,
				{ 43 ,  {123.98006476 }} ,
				{ 44 ,  {43.13717196 }} ,
				{ 45 ,  {210.24199264 }} ,
				{ 47 ,  {469.13995216 }} ,
				{ 51 ,  {217.90641985 }} ,
				{ 52 ,  {238.91298805 }} ,
				{ 53 ,  {287.26242769 }} ,
				{ 55 ,  {297.00533496 }} ,
				{ 57 ,  {310.5792773 }} ,
				{ 60 ,  {331.03594313 }} ,
				{ 61 ,  {337.38826236 }} ,
				{ 62 ,  {345.51744456 }} ,
				{ 64 ,  {520.61172947 }} ,
				{ 67 ,  {692.1009437 }} ,
				{ 68 ,  {707.74797907 }} ,
				{ 69 ,  {816.81265916 }} ,
				{ 75 ,  {96.00340237 }} ,
				{ 76 ,  {129.17022248 }} ,
				{ 80 ,  {193.36881075 }} ,
				{ 81 ,  {192.59288742 }} ,
				{ 82 ,  {184.81176238 }} ,
				{ 83 ,  {241.12137081 }} ,
				{ 86 ,  {304.56729485 }} ,
				{ 88 ,  {340.89432548 }} ,
				{ 89 ,  {367.2164339 }} ,
				{ 90 ,  {242.64398564 }} ,
				{ 94 ,  {419.36346749 }} ,
				{ 95 ,  {456.84183869 }} ,
				{ 99 ,  {501.63259526 }} ,
				{ 100 ,  {543.10577247 }} ,
				{ 102 ,  {616.90506534 }} ,
				{ 104 ,  {565.71521017 }} ,
				{ 105 ,  {577.34865081 }} ,
				{ 106 ,  {670.13118584 }} ,
				{ 110 ,  {760.21824104 }} ,
				{ 111 ,  {762.12754055 }} ,
				{ 112 ,  {753.58663382 }} ,
				{ 113 ,  {557.42418185 }} ,
				{ 120 ,  {630.47308595 }} ,
				{ 121 ,  {651.51242251 }} ,
				{ 122 ,  {680.96114859 }} ,
				{ 124 ,  {695.99180066 }} ,
				{ 125 ,  {737.40865774 }} ,
				{ 127 ,  {784.59125862 }} ,
				{ 128 ,  {859.39726521 }} ,
				{ 133 ,  {921.14633043 }} ,
				{ 135 ,  {936.08984202 }} ,
				{ 136 ,  {936.66449274 }} ,
				{ 137 ,  {897.11075364 }} ,
				{ 139 ,  {964.56286917 }} ,
				{ 140 ,  {991.65423222 }} ,
				{ 142 ,  {1054.16277579 }} ,
				{ 143 ,  {1161.77589816 }} ,
				{ 147 ,  {954.01675074 }} ,
				{ 148 ,  {1006.94766003 }} ,
				{ 150 ,  {1072.70246576 }} ,
				{ 151 ,  {1066.49672809 }} ,
				{ 155 ,  {1344.28572632 }} ,
				{ 156 ,  {1299.75326814 }} ,
				{ 157 ,  {1450.4501203 }} ,
				{ 158 ,  {1185.2623187 }} 
		};
		
	
		int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
			int lNodeIndex = (scaler_output_4 <= 0.017649224493652582) ? ( (scaler_output_4 <= -0.9838692843914032) ? ( (scaler_output_4 <= -1.4309000372886658) ? ( (scaler_output_4 <= -1.6865600943565369) ? ( (scaler_output_3 <= 1.0818820148706436) ? ( (scaler_output_2 <= -0.15695498138666153) ? ( 6 ) : ( 7 ) ) : ( 8 ) ) : ( (scaler_output_3 <= -0.4679744988679886) ? ( (scaler_output_2 <= -0.5759087726473808) ? ( 11 ) : ( (scaler_output_5 <= -1.1247649788856506) ? ( 13 ) : ( (scaler_output_3 <= -1.1088578701019287) ? ( 15 ) : ( 16 ) ) ) ) : ( (scaler_output_3 <= 0.49332664906978607) ? ( 18 ) : ( (scaler_output_5 <= -0.6441354788839817) ? ( 20 ) : ( 21 ) ) ) ) ) : ( (scaler_output_3 <= -0.08898759633302689) ? ( (scaler_output_4 <= -1.0379496812820435) ? ( (scaler_output_3 <= -0.3915177583694458) ? ( 25 ) : ( 26 ) ) : ( 27 ) ) : ( (scaler_output_2 <= -0.5878596380352974) ? ( 29 ) : ( (scaler_output_5 <= -0.5445553362369537) ? ( (scaler_output_3 <= 0.7902272269129753) ? ( 32 ) : ( 33 ) ) : ( 34 ) ) ) ) ) : ( (scaler_output_3 <= 1.1041902601718903) ? ( (scaler_output_3 <= -0.9536197185516357) ? ( (scaler_output_3 <= -1.217160552740097) ? ( (scaler_output_5 <= 1.0228291749954224) ? ( (scaler_output_4 <= -0.34222930669784546) ? ( 40 ) : ( (scaler_output_3 <= -1.4681960940361023) ? ( 42 ) : ( 43 ) ) ) : ( 44 ) ) : ( 45 ) ) : ( (scaler_output_2 <= -1.5195379257202148) ? ( 47 ) : ( (scaler_output_3 <= -0.2146232733502984) ? ( (scaler_output_4 <= -0.3802455230616033) ? ( (scaler_output_4 <= -0.7780995666980743) ? ( 51 ) : ( 52 ) ) : ( 53 ) ) : ( (scaler_output_3 <= 0.0221049627289176) ? ( 55 ) : ( (scaler_output_4 <= -0.9463390409946442) ? ( 57 ) : ( (scaler_output_5 <= 0.04505529999732971) ? ( (scaler_output_3 <= 0.6926804780960083) ? ( 60 ) : ( 61 ) ) : ( 62 ) ) ) ) ) ) ) : ( (scaler_output_4 <= -0.5779826641082764) ? ( 64 ) : ( (scaler_output_3 <= 1.560240089893341) ? ( (scaler_output_4 <= -0.3742734044790268) ? ( 67 ) : ( 68 ) ) : ( 69 ) ) ) ) ) : ( (scaler_output_3 <= 0.047109299222938716) ? ( (scaler_output_3 <= -0.8755245804786682) ? ( (scaler_output_3 <= -1.3361194133758545) ? ( (scaler_output_3 <= -1.6273767352104187) ? ( (scaler_output_4 <= 0.5106252729892731) ? ( 75 ) : ( 76 ) ) : ( (scaler_output_4 <= 1.14357990026474) ? ( (scaler_output_5 <= -0.30970026552677155) ? ( (scaler_output_3 <= -1.494538426399231) ? ( 80 ) : ( 81 ) ) : ( 82 ) ) : ( 83 ) ) ) : ( (scaler_output_2 <= 0.7943957597017288) ? ( (scaler_output_3 <= -1.2677711248397827) ? ( 86 ) : ( (scaler_output_2 <= -0.4229040741920471) ? ( 88 ) : ( 89 ) ) ) : ( 90 ) ) ) : ( (scaler_output_4 <= 0.8996041715145111) ? ( (scaler_output_3 <= -0.4353671967983246) ? ( (scaler_output_4 <= 0.5885537713766098) ? ( 94 ) : ( 95 ) ) : ( (scaler_output_4 <= 0.6764185130596161) ? ( (scaler_output_4 <= 0.2857843413949013) ? ( (scaler_output_5 <= 1.231494665145874) ? ( 99 ) : ( 100 ) ) : ( (scaler_output_4 <= 0.43903884291648865) ? ( 102 ) : ( (scaler_output_4 <= 0.5409430116415024) ? ( 104 ) : ( 105 ) ) ) ) : ( 106 ) ) ) : ( (scaler_output_4 <= 1.4812145233154297) ? ( (scaler_output_3 <= -0.06744769483339041) ? ( (scaler_output_5 <= 1.0209310054779053) ? ( 110 ) : ( 111 ) ) : ( 112 ) ) : ( 113 ) ) ) ) : ( (scaler_output_4 <= 0.9779741168022156) ? ( (scaler_output_3 <= 0.5316546559333801) ? ( (scaler_output_4 <= 0.6911941170692444) ? ( (scaler_output_2 <= -0.013490259647369385) ? ( (scaler_output_3 <= 0.4673061817884445) ? ( (scaler_output_5 <= 0.14088141918182373) ? ( 120 ) : ( 121 ) ) : ( 122 ) ) : ( (scaler_output_2 <= 0.6658321619033813) ? ( 124 ) : ( 125 ) ) ) : ( (scaler_output_4 <= 0.7820532917976379) ? ( 127 ) : ( 128 ) ) ) : ( (scaler_output_5 <= -0.13054856844246387) ? ( (scaler_output_4 <= 0.7521138191223145) ? ( (scaler_output_2 <= 0.5260942727327347) ? ( (scaler_output_2 <= -0.12999560311436653) ? ( 133 ) : ( (scaler_output_4 <= 0.434556744992733) ? ( 135 ) : ( 136 ) ) ) : ( 137 ) ) : ( (scaler_output_3 <= 0.6779933571815491) ? ( 139 ) : ( 140 ) ) ) : ( (scaler_output_4 <= 0.4838908016681671) ? ( 142 ) : ( 143 ) ) ) ) : ( (scaler_output_3 <= 0.5907565802335739) ? ( (scaler_output_3 <= 0.26137249171733856) ? ( (scaler_output_2 <= 0.4676707684993744) ? ( 147 ) : ( 148 ) ) : ( (scaler_output_2 <= 0.5297801550477743) ? ( 150 ) : ( 151 ) ) ) : ( (scaler_output_2 <= 1.5615323781967163) ? ( (scaler_output_5 <= 1.4191389679908752) ? ( (scaler_output_2 <= 0.6991206426173449) ? ( 155 ) : ( 156 ) ) : ( 157 ) ) : ( 158 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "Estimator" };
	
			return lOutputs;
		}
	
		tTable compute_regression(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
			int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			std::any  lEstimator = lNodeValue [ 0 ];
			lTable[ "Estimator" ] = { lEstimator };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_regression(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace model
	

	std::vector<std::string> get_input_names(){
		std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };

		return lFeatures;
	}

	std::vector<std::string> get_output_names(){
		std::vector<std::string> lOutputs = { "Estimator" };

		return lOutputs;
	}

	tTable compute_regression(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
		tTable lTable_imputer = imputer::compute_features(Feature_0, Feature_1, Feature_2, Feature_3);

		tTable lTable_scaler = scaler::compute_model_outputs_from_table( lTable_imputer );

		tTable lTable_model = model::compute_model_outputs_from_table( lTable_scaler );


		tTable lTable;

		std::any  lEstimator = lTable_model[ "Estimator" ][0];
		lTable[ "Estimator" ] = { lEstimator };

		return lTable;
	}

	tTable compute_model_outputs_from_table( tTable const & iTable) {
		tTable lTable = compute_regression(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);

		return lTable;
	}

} // eof namespace 


int main() {
	score_csv_file("outputs/ml2cpp-demo/datasets/freidman2.csv");
	return 0;
}
