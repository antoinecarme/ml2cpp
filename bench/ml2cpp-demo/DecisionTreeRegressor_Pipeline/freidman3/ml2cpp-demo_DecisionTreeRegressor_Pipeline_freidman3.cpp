// ******************************************************** 

// This C++ code was automatically generated by ml2cpp (development version).
// Copyright 2020

// https://github.com/antoinecarme/ml2cpp
// Model : DecisionTreeRegressor_Pipeline
// Dataset : freidman3

// This CPP code can be compiled using any C++-17 compiler.
// g++ -Wall -Wno-unused-function -std=c++17 -g -o ml2cpp-demo_DecisionTreeRegressor_Pipeline_freidman3.exe ml2cpp-demo_DecisionTreeRegressor_Pipeline_freidman3.cpp

// Model deployment code

// ******************************************************** 

#include "../../Generic.i"

namespace  {

	namespace imputer {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
	
			tTable lTable;
	
			lTable["imputer_output_2"] = { ((Feature_0 == std::any()) ?  ( 43.79128122207401 ) : ( Feature_0)) };
			lTable["imputer_output_3"] = { ((Feature_1 == std::any()) ?  ( 945.9672833084396 ) : ( Feature_1)) };
			lTable["imputer_output_4"] = { ((Feature_2 == std::any()) ?  ( 0.5310009099975209 ) : ( Feature_2)) };
			lTable["imputer_output_5"] = { ((Feature_3 == std::any()) ?  ( 6.139967152050499 ) : ( Feature_3)) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);
	
			return lTable;
		}
	
	} // eof namespace imputer
	

	namespace scaler {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any imputer_output_2, std::any imputer_output_3, std::any imputer_output_4, std::any imputer_output_5) {
	
			tTable lTable;
	
			lTable["scaler_output_2"] = { ( ( imputer_output_2 - 43.79128122207401 ) / 26.03562357622511 ) };
			lTable["scaler_output_3"] = { ( ( imputer_output_3 - 945.9672833084396 ) / 461.4552766146446 ) };
			lTable["scaler_output_4"] = { ( ( imputer_output_4 - 0.5310009099975209 ) / 0.2901863282144786 ) };
			lTable["scaler_output_5"] = { ( ( imputer_output_5 - 6.139967152050499 ) / 3.072917242564058 ) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("imputer_output_2")[0], iTable.at("imputer_output_3")[0], iTable.at("imputer_output_4")[0], iTable.at("imputer_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace scaler
	

	namespace model {
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.61001684 }} ,
				{ 5 ,  {1.14091625 }} ,
				{ 8 ,  {1.35009011 }} ,
				{ 9 ,  {1.36871758 }} ,
				{ 10 ,  {1.40929984 }} ,
				{ 13 ,  {0.80791092 }} ,
				{ 14 ,  {0.70507147 }} ,
				{ 16 ,  {0.48486692 }} ,
				{ 18 ,  {0.37516757 }} ,
				{ 19 ,  {0.38342473 }} ,
				{ 24 ,  {1.11561476 }} ,
				{ 25 ,  {1.16100714 }} ,
				{ 27 ,  {1.53596709 }} ,
				{ 28 ,  {1.45186094 }} ,
				{ 31 ,  {1.31432562 }} ,
				{ 32 ,  {1.3413442 }} ,
				{ 39 ,  {1.56967904 }} ,
				{ 40 ,  {1.57058399 }} ,
				{ 41 ,  {1.56848669 }} ,
				{ 43 ,  {1.56460912 }} ,
				{ 44 ,  {1.56427232 }} ,
				{ 45 ,  {1.55432885 }} ,
				{ 48 ,  {1.52787455 }} ,
				{ 50 ,  {1.53671123 }} ,
				{ 51 ,  {1.54158957 }} ,
				{ 53 ,  {1.56232281 }} ,
				{ 54 ,  {1.55610197 }} ,
				{ 58 ,  {1.36789414 }} ,
				{ 60 ,  {1.41074394 }} ,
				{ 61 ,  {1.42518022 }} ,
				{ 63 ,  {1.38449452 }} ,
				{ 65 ,  {1.53405928 }} ,
				{ 69 ,  {1.49656192 }} ,
				{ 70 ,  {1.49902739 }} ,
				{ 71 ,  {1.48725785 }} ,
				{ 74 ,  {1.46764868 }} ,
				{ 76 ,  {1.46424873 }} ,
				{ 77 ,  {1.46088901 }} ,
				{ 78 ,  {1.49292179 }} ,
				{ 81 ,  {1.47795145 }} ,
				{ 82 ,  {1.4771264 }} ,
				{ 86 ,  {1.50778907 }} ,
				{ 91 ,  {1.5278957 }} ,
				{ 92 ,  {1.52762941 }} ,
				{ 93 ,  {1.53181558 }} ,
				{ 95 ,  {1.5352537 }} ,
				{ 96 ,  {1.53256929 }} ,
				{ 98 ,  {1.53095005 }} ,
				{ 101 ,  {1.52208363 }} ,
				{ 102 ,  {1.52169424 }} ,
				{ 103 ,  {1.52129772 }} ,
				{ 105 ,  {1.52485398 }} ,
				{ 108 ,  {1.54561918 }} ,
				{ 110 ,  {1.54404651 }} ,
				{ 111 ,  {1.54375025 }} ,
				{ 112 ,  {1.53740023 }} ,
				{ 114 ,  {1.48471099 }} ,
				{ 116 ,  {1.50320739 }} ,
				{ 117 ,  {1.51266196 }} ,
				{ 121 ,  {1.02748435 }} ,
				{ 122 ,  {1.07654708 }} ,
				{ 125 ,  {1.14405643 }} ,
				{ 128 ,  {1.27887759 }} ,
				{ 129 ,  {1.27948723 }} ,
				{ 130 ,  {1.26722342 }} ,
				{ 132 ,  {1.1968265 }} ,
				{ 135 ,  {1.1082904 }} ,
				{ 136 ,  {1.10634412 }} ,
				{ 137 ,  {1.15778604 }} ,
				{ 139 ,  {1.081892 }} ,
				{ 142 ,  {1.34984299 }} ,
				{ 143 ,  {1.34636148 }} ,
				{ 146 ,  {1.49322332 }} ,
				{ 148 ,  {1.50282351 }} ,
				{ 149 ,  {1.50990015 }} ,
				{ 152 ,  {1.47193903 }} ,
				{ 153 ,  {1.46708262 }} ,
				{ 155 ,  {1.49496626 }} ,
				{ 157 ,  {1.48605726 }} ,
				{ 158 ,  {1.47832813 }} 
		};
		
	
		int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
			int lNodeIndex = (scaler_output_4 <= -1.4309000372886658) ? ( (scaler_output_2 <= -0.5874325856566429) ? ( (scaler_output_4 <= -1.7431707978248596) ? ( 3 ) : ( (scaler_output_3 <= -0.4679744988679886) ? ( 5 ) : ( (scaler_output_3 <= 1.3414755463600159) ? ( (scaler_output_2 <= -0.9926323592662811) ? ( 8 ) : ( 9 ) ) : ( 10 ) ) ) ) : ( (scaler_output_3 <= -1.0840756297111511) ? ( (scaler_output_2 <= 0.0887349471449852) ? ( 13 ) : ( 14 ) ) : ( (scaler_output_5 <= -0.14987096190452576) ? ( 16 ) : ( (scaler_output_3 <= -0.2956656664609909) ? ( 18 ) : ( 19 ) ) ) ) ) : ( (scaler_output_2 <= 0.6816338896751404) ? ( (scaler_output_3 <= -1.4988391995429993) ? ( (scaler_output_5 <= 0.5453606434166431) ? ( (scaler_output_4 <= -0.0005476325750350952) ? ( 24 ) : ( 25 ) ) : ( (scaler_output_3 <= -1.717117726802826) ? ( 27 ) : ( 28 ) ) ) : ( (scaler_output_4 <= -1.1697484254837036) ? ( (scaler_output_3 <= 1.10731241106987) ? ( 31 ) : ( 32 ) ) : ( (scaler_output_2 <= -0.9979358315467834) ? ( (scaler_output_2 <= -1.3966397047042847) ? ( (scaler_output_3 <= 0.6280219256877899) ? ( (scaler_output_3 <= 0.020498842000961304) ? ( (scaler_output_5 <= 1.0123527646064758) ? ( (scaler_output_4 <= 0.7431471608579159) ? ( 39 ) : ( 40 ) ) : ( 41 ) ) : ( (scaler_output_3 <= 0.42866186797618866) ? ( 43 ) : ( 44 ) ) ) : ( 45 ) ) : ( (scaler_output_4 <= 0.2322053387761116) ? ( (scaler_output_5 <= 1.0737027525901794) ? ( 48 ) : ( (scaler_output_4 <= -0.46476496011018753) ? ( 50 ) : ( 51 ) ) ) : ( (scaler_output_5 <= 0.3301943149417639) ? ( 53 ) : ( 54 ) ) ) ) : ( (scaler_output_3 <= -0.013251647469587624) ? ( (scaler_output_4 <= -0.07885412126779556) ? ( (scaler_output_5 <= -1.5075144171714783) ? ( 58 ) : ( (scaler_output_5 <= -0.6148404628038406) ? ( 60 ) : ( 61 ) ) ) : ( (scaler_output_3 <= -1.2677711248397827) ? ( 63 ) : ( (scaler_output_2 <= -0.7974012792110443) ? ( 65 ) : ( (scaler_output_2 <= -0.23644034564495087) ? ( (scaler_output_2 <= -0.3808511644601822) ? ( (scaler_output_5 <= -0.14239919185638428) ? ( 69 ) : ( 70 ) ) : ( 71 ) ) : ( (scaler_output_5 <= 1.26242196559906) ? ( (scaler_output_4 <= 0.3696778789162636) ? ( 74 ) : ( (scaler_output_4 <= 1.1107220649719238) ? ( 76 ) : ( 77 ) ) ) : ( 78 ) ) ) ) ) ) : ( (scaler_output_4 <= -0.5779826641082764) ? ( (scaler_output_2 <= -0.157425194978714) ? ( 81 ) : ( 82 ) ) : ( (scaler_output_2 <= 0.3047986254096031) ? ( (scaler_output_5 <= 0.35247907042503357) ? ( (scaler_output_4 <= -0.18692036718130112) ? ( 86 ) : ( (scaler_output_2 <= -0.19583164900541306) ? ( (scaler_output_2 <= -0.3807009756565094) ? ( (scaler_output_3 <= 0.4673061817884445) ? ( (scaler_output_4 <= 0.4007360674440861) ? ( 91 ) : ( 92 ) ) : ( 93 ) ) : ( (scaler_output_5 <= -0.9217544496059418) ? ( 95 ) : ( 96 ) ) ) : ( (scaler_output_3 <= 0.35755085945129395) ? ( 98 ) : ( (scaler_output_3 <= 0.7350868582725525) ? ( (scaler_output_5 <= -0.5815658569335938) ? ( 101 ) : ( 102 ) ) : ( 103 ) ) ) ) ) : ( (scaler_output_3 <= 0.5796983548207209) ? ( 105 ) : ( (scaler_output_2 <= -0.06669343076646328) ? ( (scaler_output_4 <= 0.10831808298826218) ? ( 108 ) : ( (scaler_output_5 <= 1.1773918867111206) ? ( 110 ) : ( 111 ) ) ) : ( 112 ) ) ) ) : ( (scaler_output_3 <= 0.824400007724762) ? ( 114 ) : ( (scaler_output_5 <= -1.113603562116623) ? ( 116 ) : ( 117 ) ) ) ) ) ) ) ) ) : ( (scaler_output_3 <= -0.20375587046146393) ? ( (scaler_output_5 <= -0.7887826561927795) ? ( (scaler_output_3 <= -1.494538426399231) ? ( 121 ) : ( 122 ) ) : ( (scaler_output_3 <= -0.8670860826969147) ? ( (scaler_output_3 <= -1.5442689657211304) ? ( 125 ) : ( (scaler_output_5 <= 0.054462283849716187) ? ( (scaler_output_2 <= 1.2351047694683075) ? ( 128 ) : ( 129 ) ) : ( 130 ) ) ) : ( (scaler_output_4 <= -1.1209805607795715) ? ( 132 ) : ( (scaler_output_2 <= 1.5003243684768677) ? ( (scaler_output_2 <= 1.1446196734905243) ? ( 135 ) : ( 136 ) ) : ( 137 ) ) ) ) ) : ( (scaler_output_4 <= -1.0818235576152802) ? ( 139 ) : ( (scaler_output_4 <= -0.49651999771595) ? ( (scaler_output_3 <= 0.3182849586009979) ? ( 142 ) : ( 143 ) ) : ( (scaler_output_5 <= 0.2622483856976032) ? ( (scaler_output_5 <= -0.8360162265598774) ? ( 146 ) : ( (scaler_output_2 <= 1.2282309532165527) ? ( 148 ) : ( 149 ) ) ) : ( (scaler_output_5 <= 0.955989420413971) ? ( (scaler_output_2 <= 1.1709603071212769) ? ( 152 ) : ( 153 ) ) : ( (scaler_output_5 <= 1.2161926627159119) ? ( 155 ) : ( (scaler_output_2 <= 0.8529378771781921) ? ( 157 ) : ( 158 ) ) ) ) ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "Estimator" };
	
			return lOutputs;
		}
	
		tTable compute_regression(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
			int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			std::any  lEstimator = lNodeValue [ 0 ];
			lTable[ "Estimator" ] = { lEstimator };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_regression(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace model
	

	std::vector<std::string> get_input_names(){
		std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };

		return lFeatures;
	}

	std::vector<std::string> get_output_names(){
		std::vector<std::string> lOutputs = { "Estimator" };

		return lOutputs;
	}

	tTable compute_regression(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
		tTable lTable_imputer = imputer::compute_features(Feature_0, Feature_1, Feature_2, Feature_3);

		tTable lTable_scaler = scaler::compute_model_outputs_from_table( lTable_imputer );

		tTable lTable_model = model::compute_model_outputs_from_table( lTable_scaler );


		tTable lTable;

		std::any  lEstimator = lTable_model[ "Estimator" ][0];
		lTable[ "Estimator" ] = { lEstimator };

		return lTable;
	}

	tTable compute_model_outputs_from_table( tTable const & iTable) {
		tTable lTable = compute_regression(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);

		return lTable;
	}

} // eof namespace 


int main() {
	score_csv_file("outputs/ml2cpp-demo/datasets/freidman3.csv");
	return 0;
}
