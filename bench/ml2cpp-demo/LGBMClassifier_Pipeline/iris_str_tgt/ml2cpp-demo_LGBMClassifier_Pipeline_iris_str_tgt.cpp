// ******************************************************** 

// This C++ code was automatically generated by ml2cpp (development version).
// Copyright 2020

// https://github.com/antoinecarme/ml2cpp
// Model : LGBMClassifier_Pipeline
// Dataset : iris_str_tgt

// This CPP code can be compiled using any C++-17 compiler.
// g++ -Wall -Wno-unused-function -std=c++17 -g -o ml2cpp-demo_LGBMClassifier_Pipeline_iris_str_tgt.exe ml2cpp-demo_LGBMClassifier_Pipeline_iris_str_tgt.cpp

// Model deployment code

// ******************************************************** 

#include "../../Generic.i"

namespace  {

	std::vector<std::string> get_classes(){
		std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };

		return lClasses;
	}

	namespace imputer {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
	
			tTable lTable;
	
			lTable["imputer_output_2"] = { ((Feature_0 == std::any()) ?  ( 5.8474999999999975 ) : ( Feature_0)) };
			lTable["imputer_output_3"] = { ((Feature_1 == std::any()) ?  ( 3.040833333333332 ) : ( Feature_1)) };
			lTable["imputer_output_4"] = { ((Feature_2 == std::any()) ?  ( 3.844166666666667 ) : ( Feature_2)) };
			lTable["imputer_output_5"] = { ((Feature_3 == std::any()) ?  ( 1.2458333333333336 ) : ( Feature_3)) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);
	
			return lTable;
		}
	
	} // eof namespace imputer
	

	namespace scaler {
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "imputer_output_2", "imputer_output_3", "imputer_output_4", "imputer_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lOutputs;
		}
	
		tTable compute_features(std::any imputer_output_2, std::any imputer_output_3, std::any imputer_output_4, std::any imputer_output_5) {
	
			tTable lTable;
	
			lTable["scaler_output_2"] = { ( ( imputer_output_2 - 5.8474999999999975 ) / 0.827039146594646 ) };
			lTable["scaler_output_3"] = { ( ( imputer_output_3 - 3.040833333333332 ) / 0.43922200789830873 ) };
			lTable["scaler_output_4"] = { ( ( imputer_output_4 - 3.844166666666667 ) / 1.7109839193347847 ) };
			lTable["scaler_output_5"] = { ( ( imputer_output_5 - 1.2458333333333336 ) / 0.7486538845747673 ) };
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_features(iTable.at("imputer_output_2")[0], iTable.at("imputer_output_3")[0], iTable.at("imputer_output_4")[0], iTable.at("imputer_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace scaler
	

	namespace model {
	
		std::vector<std::string> get_classes(){
			std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
	
			return lClasses;
		}
	
		namespace LGBM_Tree_0_0 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {-1.098577633576391 }} ,
					{ 3 ,  {-1.2127184097138204 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_0
		
	
		namespace LGBM_Tree_1_0 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-1.1361122895063 }} ,
					{ 4 ,  {-1.1331517631243377 }} ,
					{ 10 ,  {-1.0236122869917292 }} ,
					{ 11 ,  {-1.066469430806804 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_0
		
	
		namespace LGBM_Tree_2_0 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-1.0548975721429792 }} ,
					{ 6 ,  {-0.972833457269183 }} ,
					{ 7 ,  {-0.9565241852280185 }} ,
					{ 8 ,  {-1.0652526655024486 }} ,
					{ 9 ,  {-1.0652526655024486 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_0
		
	
		namespace LGBM_Tree_0_1 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.07203709754130887 }} ,
					{ 6 ,  {-0.03560466438872138 }} ,
					{ 14 ,  {-0.03546232753800146 }} ,
					{ 15 ,  {-0.03557263246000808 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_1
		
	
		namespace LGBM_Tree_1_1 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {-0.03687402568505773 }} ,
					{ 12 ,  {0.05471091282297931 }} ,
					{ 13 ,  {0.06549038259359759 }} ,
					{ 14 ,  {-0.020160621203689815 }} ,
					{ 15 ,  {-0.036848255606056916 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_2 <= -0.11789042925169398 ) ? ( 12 ) : ( 13 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_1
		
	
		namespace LGBM_Tree_2_1 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.02794490709807418 }} ,
					{ 6 ,  {0.050456153796761306 }} ,
					{ 7 ,  {0.06536468519994394 }} ,
					{ 8 ,  {-0.038146971656005446 }} ,
					{ 9 ,  {-0.03814000705850624 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_1
		
	
		namespace LGBM_Tree_0_2 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.06710583031172605 }} ,
					{ 6 ,  {-0.03507439933836642 }} ,
					{ 14 ,  {-0.03490998640237942 }} ,
					{ 15 ,  {-0.035004861891144254 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_2
		
	
		namespace LGBM_Tree_1_2 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {-0.036308694220767664 }} ,
					{ 12 ,  {0.05183542073163149 }} ,
					{ 13 ,  {0.061350994955675364 }} ,
					{ 14 ,  {-0.01955410437926108 }} ,
					{ 15 ,  {-0.036164628007685835 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_2 <= -0.11789042925169398 ) ? ( 12 ) : ( 13 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_2
		
	
		namespace LGBM_Tree_2_2 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.027175741831872935 }} ,
					{ 6 ,  {0.047634793193730714 }} ,
					{ 7 ,  {0.061466030358232684 }} ,
					{ 8 ,  {-0.037360474274365625 }} ,
					{ 9 ,  {-0.03742598346375149 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_2
		
	
		namespace LGBM_Tree_0_3 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.06288417480323484 }} ,
					{ 6 ,  {-0.034588139626609414 }} ,
					{ 14 ,  {-0.03440569155695775 }} ,
					{ 15 ,  {-0.03446795493205667 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.44175361602883695 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.7632060819373623 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_3
		
	
		namespace LGBM_Tree_1_3 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {-0.03570855183326651 }} ,
					{ 7 ,  {-0.030522505306779326 }} ,
					{ 12 ,  {0.05513184020491312 }} ,
					{ 13 ,  {0.04671403387150432 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_3
		
	
		namespace LGBM_Tree_2_3 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.026428733936072608 }} ,
					{ 6 ,  {0.04510991997777966 }} ,
					{ 7 ,  {0.05809329936406861 }} ,
					{ 8 ,  {-0.03663376207423026 }} ,
					{ 9 ,  {-0.03675053679260615 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_3
		
	
		namespace LGBM_Tree_0_4 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.059249424563210244 }} ,
					{ 6 ,  {-0.034139483803533176 }} ,
					{ 14 ,  {-0.0338682214733499 }} ,
					{ 15 ,  {-0.03394220726138208 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_4
		
	
		namespace LGBM_Tree_1_4 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.03526170605977342 }} ,
					{ 4 ,  {-0.032151011171800005 }} ,
					{ 10 ,  {0.059151204965902905 }} ,
					{ 11 ,  {0.02739817862696709 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_4
		
	
		namespace LGBM_Tree_2_4 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.025879323134733852 }} ,
					{ 6 ,  {0.04304016306737694 }} ,
					{ 7 ,  {0.055229940647735946 }} ,
					{ 8 ,  {-0.03595304601527121 }} ,
					{ 9 ,  {-0.03610540456473311 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_4
		
	
		namespace LGBM_Tree_0_5 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.05599767583132714 }} ,
					{ 6 ,  {-0.03369616217069678 }} ,
					{ 14 ,  {-0.03336218480130148 }} ,
					{ 15 ,  {-0.033489673174888664 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_5
		
	
		namespace LGBM_Tree_1_5 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.034713002480153396 }} ,
					{ 4 ,  {-0.03156203262598963 }} ,
					{ 10 ,  {0.056144291694111226 }} ,
					{ 11 ,  {0.026222882372044145 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_5
		
	
		namespace LGBM_Tree_2_5 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.025273928047555044 }} ,
					{ 6 ,  {0.041894429027994375 }} ,
					{ 7 ,  {0.05350233245386084 }} ,
					{ 8 ,  {-0.03533603196091717 }} ,
					{ 9 ,  {-0.03547323670914954 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_5
		
	
		namespace LGBM_Tree_0_6 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.053145108405744206 }} ,
					{ 6 ,  {-0.03327635444917742 }} ,
					{ 14 ,  {-0.03291530769909316 }} ,
					{ 15 ,  {-0.033036150217049726 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_6
		
	
		namespace LGBM_Tree_1_6 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {-0.034206556691768135 }} ,
					{ 7 ,  {-0.029164965472322127 }} ,
					{ 12 ,  {0.04831887704248408 }} ,
					{ 13 ,  {0.04151320992791824 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_6
		
	
		namespace LGBM_Tree_2_6 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.04847832460710317 }} ,
					{ 5 ,  {-0.01723918230110742 }} ,
					{ 8 ,  {-0.034762801723106605 }} ,
					{ 9 ,  {-0.03511596385110626 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_6
		
	
		namespace LGBM_Tree_0_7 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.05068525826516349 }} ,
					{ 6 ,  {-0.03287388507221969 }} ,
					{ 14 ,  {-0.03251983451376361 }} ,
					{ 15 ,  {-0.03261792547942402 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_7
		
	
		namespace LGBM_Tree_1_7 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.03385142114716804 }} ,
					{ 4 ,  {-0.03371950595207674 }} ,
					{ 10 ,  {0.0471443591542228 }} ,
					{ 11 ,  {0.024564110303857398 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_7
		
	
		namespace LGBM_Tree_2_7 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.024395225365071625 }} ,
					{ 6 ,  {0.03859271803929604 }} ,
					{ 7 ,  {0.04939745719485434 }} ,
					{ 8 ,  {-0.03420394206113458 }} ,
					{ 9 ,  {-0.03435243349876829 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_4 <= 0.9969896935071989 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_7
		
	
		namespace LGBM_Tree_0_8 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.048498810954971605 }} ,
					{ 6 ,  {-0.03251116796550338 }} ,
					{ 14 ,  {-0.032216412351179516 }} ,
					{ 15 ,  {-0.032130234428115405 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_8
		
	
		namespace LGBM_Tree_1_8 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.03338082069192506 }} ,
					{ 4 ,  {-0.03331143106484881 }} ,
					{ 10 ,  {0.04542036345029271 }} ,
					{ 11 ,  {0.02356847480030867 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_8
		
	
		namespace LGBM_Tree_2_8 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.023842838714539263 }} ,
					{ 6 ,  {0.03622613217683845 }} ,
					{ 7 ,  {0.04693561159037301 }} ,
					{ 8 ,  {-0.033686507784718746 }} ,
					{ 9 ,  {-0.033849651209211906 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_8
		
	
		namespace LGBM_Tree_0_9 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.0465394611940145 }} ,
					{ 6 ,  {-0.03216640541899468 }} ,
					{ 14 ,  {-0.03186118583313035 }} ,
					{ 15 ,  {-0.03174240507767745 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_9
		
	
		namespace LGBM_Tree_1_9 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.032943283475885966 }} ,
					{ 4 ,  {-0.032875684639598134 }} ,
					{ 10 ,  {0.043689559243602565 }} ,
					{ 11 ,  {0.02264906126520682 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_9
		
	
		namespace LGBM_Tree_2_9 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.04348381263648364 }} ,
					{ 5 ,  {-0.016528860614149935 }} ,
					{ 8 ,  {-0.03321200864312551 }} ,
					{ 9 ,  {-0.033649938701344535 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_9
		
	
		namespace LGBM_Tree_0_10 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.0447790053327801 }} ,
					{ 6 ,  {-0.03181639101439957 }} ,
					{ 14 ,  {-0.03155995923733284 }} ,
					{ 15 ,  {-0.03138561810980161 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_10
		
	
		namespace LGBM_Tree_1_10 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.03255969186440175 }} ,
					{ 4 ,  {-0.032514520030900274 }} ,
					{ 10 ,  {0.04231776764603347 }} ,
					{ 11 ,  {0.021836778626793073 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_10
		
	
		namespace LGBM_Tree_2_10 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.04202302556367313 }} ,
					{ 5 ,  {-0.01615048952202365 }} ,
					{ 8 ,  {-0.03276000924896212 }} ,
					{ 9 ,  {-0.033208293330844005 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_10
		
	
		namespace LGBM_Tree_0_11 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.043185809436165 }} ,
					{ 6 ,  {-0.03148595129797325 }} ,
					{ 14 ,  {-0.03127803466761719 }} ,
					{ 15 ,  {-0.03104942574111612 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( 6 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 14 ) : ( 15 ) ) ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_11
		
	
		namespace LGBM_Tree_1_11 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.032199938420065036 }} ,
					{ 4 ,  {-0.03212187847833443 }} ,
					{ 10 ,  {0.040898935735628486 }} ,
					{ 11 ,  {0.021073446390819855 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_11
		
	
		namespace LGBM_Tree_2_11 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 5 ,  {-0.02268301100850852 }} ,
					{ 6 ,  {0.03282194389506779 }} ,
					{ 7 ,  {0.04262264588106126 }} ,
					{ 8 ,  {-0.0323250127234722 }} ,
					{ 9 ,  {-0.03252273324995232 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5878683732599849 ) ? ( ( ( scaler_output_4 <= 0.23719295590522982 ) ? ( ( ( scaler_output_2 <= -0.8433699938775219 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_11
		
	
		namespace LGBM_Tree_0_12 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.04174118804990898 }} ,
					{ 7 ,  {-0.03072427344481081 }} ,
					{ 12 ,  {-0.03095300320395938 }} ,
					{ 13 ,  {-0.031263363983538225 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_12
		
	
		namespace LGBM_Tree_1_12 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.031832102499346863 }} ,
					{ 4 ,  {-0.031803149073094374 }} ,
					{ 10 ,  {0.039758068565201844 }} ,
					{ 11 ,  {0.020296531017118803 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_12
		
	
		namespace LGBM_Tree_2_12 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.0396666661188759 }} ,
					{ 5 ,  {-0.015730041646917933 }} ,
					{ 8 ,  {-0.03193837573522237 }} ,
					{ 9 ,  {-0.03242046259370106 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_12
		
	
		namespace LGBM_Tree_0_13 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.04042297585669757 }} ,
					{ 7 ,  {-0.030424922101528612 }} ,
					{ 12 ,  {-0.03066130472492843 }} ,
					{ 13 ,  {-0.030992990547433652 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_13
		
	
		namespace LGBM_Tree_1_13 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.03151418706851478 }} ,
					{ 4 ,  {-0.03144959359970684 }} ,
					{ 10 ,  {0.03856481867136396 }} ,
					{ 11 ,  {0.019614723402753966 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_5 <= -1.063019039546377 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_13
		
	
		namespace LGBM_Tree_2_13 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 4 ,  {-0.024999910685942105 }} ,
					{ 6 ,  {0.026394400790221206 }} ,
					{ 7 ,  {0.04087730872717531 }} ,
					{ 10 ,  {-0.03158227243048794 }} ,
					{ 11 ,  {-0.03289703619943964 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.5294224703675258 ) ? ( ( ( scaler_output_3 <= -0.6621556481765994 ) ? ( 4 ) : ( ( ( scaler_output_2 <= -0.6620001027210645 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( ( ( scaler_output_4 <= 0.8800978877222807 ) ? ( 6 ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_13
		
	
		namespace LGBM_Tree_0_14 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.03921986107914058 }} ,
					{ 7 ,  {-0.030149015861194863 }} ,
					{ 12 ,  {-0.03037455394316346 }} ,
					{ 13 ,  {-0.03073712113593486 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_14
		
	
		namespace LGBM_Tree_1_14 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.031183916074223657 }} ,
					{ 4 ,  {-0.031168211882030623 }} ,
					{ 10 ,  {0.037639119576233844 }} ,
					{ 11 ,  {0.018876527774799243 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_14
		
	
		namespace LGBM_Tree_2_14 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.03763380408977582 }} ,
					{ 5 ,  {-0.015279318344802499 }} ,
					{ 8 ,  {-0.0312142883947812 }} ,
					{ 9 ,  {-0.031730147330013996 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_14
		
	
		namespace LGBM_Tree_0_15 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 2 ,  {0.0381125588785606 }} ,
					{ 7 ,  {-0.02988176832820983 }} ,
					{ 12 ,  {-0.03011387163471796 }} ,
					{ 13 ,  {-0.030496240065494458 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 2 ) : ( ( ( scaler_output_5 <= 0.9405770559337051 ) ? ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 12 ) : ( 13 ) ) ) : ( 7 ) ) ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					lNodeValue [ 0 ],
					0.0,
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_0_15
		
	
		namespace LGBM_Tree_1_15 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {-0.030902637439763198 }} ,
					{ 4 ,  {-0.03085024460385748 }} ,
					{ 10 ,  {0.03662201043150378 }} ,
					{ 11 ,  {0.01826803553273802 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_4 <= 0.7047601790449031 ) ? ( ( ( scaler_output_4 <= -1.1947316649600193 ) ? ( 4 ) : ( ( ( scaler_output_5 <= 0.2727116907736775 ) ? ( 10 ) : ( 11 ) ) ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					lNodeValue [ 0 ],
					0.0 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_1_15
		
	
		namespace LGBM_Tree_2_15 {
		
			std::vector<std::string> get_classes(){
				std::vector<std::string> lClasses = { "CLASS_0", "CLASS_1", "CLASS_2" };
		
				return lClasses;
			}
		
			typedef std::vector<double> tNodeData;
			std::map<int, tNodeData> Decision_Tree_Node_data = {
					{ 3 ,  {0.036664559671497406 }} ,
					{ 5 ,  {-0.014932936214246947 }} ,
					{ 8 ,  {-0.030884238534663183 }} ,
					{ 9 ,  {-0.03139819022339432 }} 
			};
			
		
			int get_decision_tree_node_index(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				int lNodeIndex = ( ( scaler_output_5 <= 0.5398578368376886 ) ? ( ( ( scaler_output_2 <= 0.12393609229024888 ) ? ( ( ( scaler_output_4 <= -0.40571197591182095 ) ? ( 8 ) : ( 9 ) ) ) : ( 5 ) ) ) : ( 3 ) );
			
				return lNodeIndex;
			}
			
		
			std::vector<std::string> get_input_names(){
				std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
		
				return lFeatures;
			}
		
			std::vector<std::string> get_output_names(){
				std::vector<std::string> lOutputs = { 
					"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
					"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
					"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2" };
		
				return lOutputs;
			}
		
			tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
				auto lClasses = get_classes();
		
				int lNodeIndex = get_decision_tree_node_index(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5);
		
				std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
		
		
				tTable lTable;
		
				lTable["Score"] = { 
					0.0,
					0.0,
					lNodeValue [ 0 ] 
				} ;
				lTable["Proba"] = { 
					std::any(),
					std::any(),
					std::any() 
				} ;
		
				recompute_log_probas( lTable );
		
				return lTable;
			}
		
			tTable compute_model_outputs_from_table( tTable const & iTable) {
				tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
		
				return lTable;
			}
		
		} // eof namespace LGBM_Tree_2_15
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "scaler_output_2", "scaler_output_3", "scaler_output_4", "scaler_output_5" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
				"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
				"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any scaler_output_2, std::any scaler_output_3, std::any scaler_output_4, std::any scaler_output_5) {
			auto lClasses = get_classes();
	
			std::vector<tTable> lTreeScores = { 
				LGBM_Tree_0_0::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_0::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_0::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_1::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_1::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_1::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_2::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_2::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_2::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_3::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_3::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_3::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_4::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_4::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_4::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_5::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_5::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_5::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_6::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_6::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_6::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_7::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_7::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_7::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_8::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_8::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_8::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_9::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_9::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_9::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_10::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_10::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_10::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_11::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_11::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_11::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_12::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_12::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_12::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_13::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_13::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_13::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_14::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_14::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_14::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_0_15::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_1_15::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5),
				LGBM_Tree_2_15::compute_classification_scores(scaler_output_2, scaler_output_3, scaler_output_4, scaler_output_5)
			};
	
			tTable lAggregatedTable = aggregate_lgb_scores(lTreeScores, {"Score"});
	
			tTable lSoftMaxTable = soft_max(lAggregatedTable);
	
	
			tTable lTable = lSoftMaxTable;
	
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("scaler_output_2")[0], iTable.at("scaler_output_3")[0], iTable.at("scaler_output_4")[0], iTable.at("scaler_output_5")[0]);
	
			return lTable;
		}
	
	} // eof namespace model
	

	std::vector<std::string> get_input_names(){
		std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3" };

		return lFeatures;
	}

	std::vector<std::string> get_output_names(){
		std::vector<std::string> lOutputs = { 
			"Score_CLASS_0", "Score_CLASS_1", "Score_CLASS_2",
			"Proba_CLASS_0", "Proba_CLASS_1", "Proba_CLASS_2",
			"LogProba_CLASS_0", "LogProba_CLASS_1", "LogProba_CLASS_2",
			"Decision", "DecisionProba" };

		return lOutputs;
	}

	tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3) {
		auto lClasses = get_classes();

		tTable lTable_imputer = imputer::compute_features(Feature_0, Feature_1, Feature_2, Feature_3);

		tTable lTable_scaler = scaler::compute_model_outputs_from_table( lTable_imputer );

		tTable lTable_model = model::compute_model_outputs_from_table( lTable_scaler );


		tTable lTable = lTable_model;

		int lBestClass = get_arg_max( lTable["Proba"] );
		auto lDecision = lClasses[lBestClass];
		lTable["Decision"] = { lDecision } ;
		lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };

		recompute_log_probas( lTable );

		return lTable;
	}

	tTable compute_model_outputs_from_table( tTable const & iTable) {
		tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0]);

		return lTable;
	}

} // eof namespace 


int main() {
	score_csv_file("outputs/ml2cpp-demo/datasets/iris_str_tgt.csv");
	return 0;
}
