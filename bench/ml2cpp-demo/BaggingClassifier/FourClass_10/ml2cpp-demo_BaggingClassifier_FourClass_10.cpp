// ******************************************************** 

// This C++ code was automatically generated by ml2cpp (development version).
// Copyright 2020

// https://github.com/antoinecarme/ml2cpp
// Model : BaggingClassifier
// Dataset : FourClass_10

// This CPP code can be compiled using any C++-17 compiler.
// g++ -Wall -Wno-unused-function -std=c++17 -g -o ml2cpp-demo_BaggingClassifier_FourClass_10.exe ml2cpp-demo_BaggingClassifier_FourClass_10.cpp

// Model deployment code

// ******************************************************** 

#include "../../Generic.i"

namespace  {

	std::vector<std::any> get_classes(){
		std::vector<std::any> lClasses = { 0, 1, 2, 3 };

		return lClasses;
	}

	namespace SubModel_0 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 4 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 6 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 8 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 15 ,  {0.9583333333333334, 0.0, 0.0, 0.041666666666666664 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 20 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 25 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 26 ,  {1.0, 0.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_4 <= -0.7205710709095001) ? ( (Feature_1 <= -0.3766303211450577) ? ( 2 ) : ( (Feature_7 <= -0.02593889832496643) ? ( 4 ) : ( (Feature_7 <= 1.2799879908561707) ? ( 6 ) : ( (Feature_4 <= -2.2154770493507385) ? ( 8 ) : ( 9 ) ) ) ) ) : ( (Feature_3 <= 0.6257461905479431) ? ( (Feature_6 <= 1.1597294807434082) ? ( (Feature_2 <= -2.539427638053894) ? ( 13 ) : ( (Feature_2 <= 0.6566844582557678) ? ( 15 ) : ( 16 ) ) ) : ( 17 ) ) : ( (Feature_6 <= -1.1888949275016785) ? ( (Feature_7 <= 1.096362978219986) ? ( 20 ) : ( (Feature_8 <= -0.1138073205947876) ? ( 22 ) : ( 23 ) ) ) : ( (Feature_0 <= 0.4317001663148403) ? ( 25 ) : ( 26 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_0
	

	namespace SubModel_1 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 11 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 18 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 20 ,  {0.0, 0.3333333333333333, 0.0, 0.6666666666666666 }} ,
				{ 21 ,  {0.0, 0.96, 0.0, 0.04 }} ,
				{ 23 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.5939029157161713) ? ( (Feature_4 <= -0.35484130680561066) ? ( (Feature_1 <= 0.36407171934843063) ? ( (Feature_5 <= 0.07402315735816956) ? ( 4 ) : ( 5 ) ) : ( (Feature_9 <= -0.03236502781510353) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_3 <= -2.2557533979415894) ? ( 10 ) : ( 11 ) ) ) : ( (Feature_8 <= 1.0354389548301697) ? ( (Feature_0 <= -1.4770508408546448) ? ( 14 ) : ( (Feature_1 <= -0.12893121317029) ? ( (Feature_0 <= -0.3409147784113884) ? ( 17 ) : ( 18 ) ) : ( (Feature_4 <= -1.7061595916748047) ? ( 20 ) : ( 21 ) ) ) ) : ( (Feature_5 <= 0.7421096861362457) ? ( 23 ) : ( 24 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_1
	

	namespace SubModel_2 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 15 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 25 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= 0.2519511356949806) ? ( (Feature_7 <= 0.5543844103813171) ? ( (Feature_5 <= 0.07402315735816956) ? ( (Feature_4 <= 0.4352496713399887) ? ( 4 ) : ( 5 ) ) : ( (Feature_2 <= 1.9205785170197487) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_1 <= -0.5793455839157104) ? ( 10 ) : ( 11 ) ) ) : ( (Feature_7 <= 0.44504228234291077) ? ( (Feature_4 <= 0.9742768108844757) ? ( (Feature_2 <= -1.900172233581543) ? ( 15 ) : ( 16 ) ) : ( (Feature_5 <= -0.12828787043690681) ? ( 18 ) : ( 19 ) ) ) : ( (Feature_8 <= -1.1262891292572021) ? ( 21 ) : ( (Feature_4 <= 0.5298123210668564) ? ( (Feature_7 <= 0.6106350421905518) ? ( 24 ) : ( 25 ) ) : ( 26 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_2
	

	namespace SubModel_3 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 11 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 15 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 23 ,  {0.0, 0.9565217391304348, 0.0, 0.043478260869565216 }} ,
				{ 24 ,  {0.0, 0.0, 0.0, 1.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.6734017729759216) ? ( (Feature_4 <= -0.38003355264663696) ? ( (Feature_1 <= -0.3766303211450577) ? ( (Feature_3 <= -0.7281682938337326) ? ( 4 ) : ( 5 ) ) : ( (Feature_2 <= -1.900172233581543) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_6 <= 1.2741605043411255) ? ( (Feature_5 <= 0.9470316544175148) ? ( 11 ) : ( 12 ) ) : ( 13 ) ) ) : ( (Feature_9 <= -2.268771708011627) ? ( 15 ) : ( (Feature_1 <= -0.12893121317029) ? ( (Feature_6 <= -0.7937459647655487) ? ( 18 ) : ( 19 ) ) : ( (Feature_7 <= -0.32661987096071243) ? ( 21 ) : ( (Feature_1 <= 2.708956480026245) ? ( 23 ) : ( 24 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_3
	

	namespace SubModel_4 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 10 ,  {0.2727272727272727, 0.0, 0.0, 0.7272727272727273 }} ,
				{ 11 ,  {0.0, 0.3333333333333333, 0.6111111111111112, 0.05555555555555555 }} ,
				{ 14 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_2 <= 1.0767131447792053) ? ( (Feature_8 <= -1.5628834962844849) ? ( 2 ) : ( (Feature_3 <= -1.7759541869163513) ? ( 4 ) : ( (Feature_1 <= -0.18501364439725876) ? ( (Feature_4 <= -1.9389472603797913) ? ( 7 ) : ( 8 ) ) : ( (Feature_7 <= -0.46776116639375687) ? ( 10 ) : ( 11 ) ) ) ) ) : ( (Feature_1 <= 2.4217634201049805) ? ( (Feature_6 <= -0.7187981009483337) ? ( 14 ) : ( 15 ) ) : ( 16 ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_4
	

	namespace SubModel_5 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 12 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 15 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 25 ,  {0.5, 0.5, 0.0, 0.0 }} ,
				{ 27 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 28 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_7 <= 0.362348735332489) ? ( (Feature_3 <= -0.697431281208992) ? ( (Feature_5 <= 0.07402315735816956) ? ( (Feature_9 <= 0.12583326920866966) ? ( 4 ) : ( 5 ) ) : ( (Feature_1 <= -0.3766303211450577) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_1 <= -0.5951647609472275) ? ( 10 ) : ( (Feature_4 <= -0.10374534130096436) ? ( 12 ) : ( (Feature_3 <= 3.205297827720642) ? ( 14 ) : ( 15 ) ) ) ) ) : ( (Feature_1 <= 0.17078124731779099) ? ( (Feature_6 <= -0.8221747577190399) ? ( 18 ) : ( 19 ) ) : ( (Feature_2 <= 0.21300425380468369) ? ( (Feature_7 <= 0.6106350421905518) ? ( 22 ) : ( (Feature_4 <= 0.5298123210668564) ? ( 24 ) : ( 25 ) ) ) : ( (Feature_9 <= -2.074081063270569) ? ( 27 ) : ( 28 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_5
	

	namespace SubModel_6 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 23 ,  {0.0, 0.5, 0.5, 0.0 }} ,
				{ 25 ,  {0.0, 0.6666666666666666, 0.0, 0.3333333333333333 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.7143889665603638) ? ( (Feature_8 <= -0.059365639463067055) ? ( (Feature_7 <= 0.16708890348672867) ? ( 3 ) : ( (Feature_1 <= -0.08559859544038773) ? ( 5 ) : ( 6 ) ) ) : ( (Feature_3 <= -1.1015613675117493) ? ( (Feature_1 <= 0.9861354976892471) ? ( 9 ) : ( 10 ) ) : ( 11 ) ) ) : ( (Feature_7 <= 0.4184545576572418) ? ( (Feature_2 <= 0.17803184391232207) ? ( 14 ) : ( (Feature_9 <= 1.1536568999290466) ? ( 16 ) : ( 17 ) ) ) : ( (Feature_9 <= -1.589853823184967) ? ( 19 ) : ( (Feature_2 <= 0.23278451338410378) ? ( (Feature_3 <= 1.7188237309455872) ? ( 22 ) : ( 23 ) ) : ( (Feature_7 <= 0.5804324746131897) ? ( 25 ) : ( 26 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_6
	

	namespace SubModel_7 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 12 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.125, 0.875, 0.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 19 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 25 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_4 <= -0.22726380452513695) ? ( (Feature_3 <= -1.1015613675117493) ? ( (Feature_8 <= -1.3122215569019318) ? ( 3 ) : ( 4 ) ) : ( (Feature_7 <= 0.13015832379460335) ? ( (Feature_3 <= -0.697431281208992) ? ( 7 ) : ( 8 ) ) : ( (Feature_8 <= -1.3037872910499573) ? ( 10 ) : ( (Feature_1 <= -0.28247935324907303) ? ( 12 ) : ( 13 ) ) ) ) ) : ( (Feature_3 <= 0.6257461905479431) ? ( (Feature_6 <= 0.5397647023200989) ? ( 16 ) : ( (Feature_4 <= 1.3200150728225708) ? ( 18 ) : ( 19 ) ) ) : ( (Feature_0 <= -0.27478233724832535) ? ( (Feature_3 <= 3.8351510763168335) ? ( 22 ) : ( 23 ) ) : ( (Feature_3 <= 2.177865207195282) ? ( 25 ) : ( 26 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_7
	

	namespace SubModel_8 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 9 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 12 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 17 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 0.9323715269565582) ? ( (Feature_3 <= -1.7722215056419373) ? ( 2 ) : ( (Feature_4 <= -0.35484130680561066) ? ( (Feature_1 <= 0.37201856821775436) ? ( (Feature_7 <= 0.6384981572628021) ? ( 6 ) : ( 7 ) ) : ( (Feature_7 <= 0.7977391481399536) ? ( 9 ) : ( 10 ) ) ) : ( (Feature_5 <= 1.0481320470571518) ? ( 12 ) : ( 13 ) ) ) ) : ( (Feature_7 <= 0.5804324746131897) ? ( (Feature_3 <= 1.9839490056037903) ? ( (Feature_3 <= 1.4057671427726746) ? ( 17 ) : ( 18 ) ) : ( 19 ) ) : ( (Feature_7 <= 3.131764531135559) ? ( 21 ) : ( 22 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_8
	

	namespace SubModel_9 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 2 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 10 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 23 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 24 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= -0.14788957685232162) ? ( (Feature_3 <= -1.9042950868606567) ? ( 2 ) : ( (Feature_4 <= -0.7451081573963165) ? ( (Feature_8 <= -0.969406247138977) ? ( 5 ) : ( 6 ) ) : ( 7 ) ) ) : ( (Feature_7 <= 0.44504228234291077) ? ( (Feature_4 <= -0.13814806938171387) ? ( 10 ) : ( (Feature_7 <= 0.07134207338094711) ? ( 12 ) : ( 13 ) ) ) : ( (Feature_3 <= 1.6230233907699585) ? ( (Feature_1 <= 0.7405263483524323) ? ( 16 ) : ( (Feature_1 <= 1.9193854331970215) ? ( 18 ) : ( 19 ) ) ) : ( (Feature_8 <= 1.0397457480430603) ? ( 21 ) : ( (Feature_0 <= 1.407631516456604) ? ( 23 ) : ( 24 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_9
	

	namespace SubModel_10 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 15 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.5, 0.0, 0.5 }} ,
				{ 20 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= -0.6974010020494461) ? ( (Feature_5 <= 0.15964942425489426) ? ( (Feature_5 <= -0.3680424615740776) ? ( 3 ) : ( 4 ) ) : ( (Feature_0 <= -1.0191061198711395) ? ( 6 ) : ( 7 ) ) ) : ( (Feature_7 <= 0.362348735332489) ? ( (Feature_4 <= -0.17202873155474663) ? ( 10 ) : ( (Feature_3 <= 3.3974949717521667) ? ( 12 ) : ( 13 ) ) ) : ( (Feature_1 <= 0.04064379632472992) ? ( 15 ) : ( (Feature_8 <= -0.580148383975029) ? ( 17 ) : ( (Feature_7 <= 0.932153731584549) ? ( 19 ) : ( 20 ) ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_10
	

	namespace SubModel_11 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 1 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 9 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 10 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 11 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 16 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 18 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= -1.9042950868606567) ? ( 1 ) : ( (Feature_3 <= 1.5620883703231812) ? ( (Feature_4 <= -0.35484130680561066) ? ( (Feature_7 <= -0.04635188356041908) ? ( (Feature_2 <= -1.900172233581543) ? ( 6 ) : ( 7 ) ) : ( (Feature_2 <= -0.8729895502328873) ? ( 9 ) : ( 10 ) ) ) : ( 11 ) ) : ( (Feature_7 <= 0.4184545576572418) ? ( 13 ) : ( (Feature_2 <= 0.265608049929142) ? ( (Feature_1 <= 1.1558878719806671) ? ( 16 ) : ( 17 ) ) : ( 18 ) ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_11
	

	namespace SubModel_12 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 3 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 6 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 11 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 13 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 14 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 16 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 17 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 21 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 22 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.0, 0.0, 0.8333333333333334, 0.16666666666666666 }} ,
				{ 25 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_1 <= -0.029132284224033356) ? ( (Feature_7 <= 0.3409436233341694) ? ( (Feature_0 <= 2.0923611521720886) ? ( 3 ) : ( 4 ) ) : ( (Feature_3 <= 1.7177826762199402) ? ( 6 ) : ( 7 ) ) ) : ( (Feature_7 <= 0.362348735332489) ? ( (Feature_4 <= 0.9742768108844757) ? ( (Feature_4 <= -0.2062663435935974) ? ( 11 ) : ( (Feature_8 <= 0.39887685328722) ? ( 13 ) : ( 14 ) ) ) : ( (Feature_3 <= -0.23729708790779114) ? ( 16 ) : ( 17 ) ) ) : ( (Feature_2 <= 0.21300425380468369) ? ( (Feature_9 <= 0.05315040051937103) ? ( (Feature_3 <= 0.32802700996398926) ? ( 21 ) : ( 22 ) ) : ( (Feature_4 <= 0.02527746558189392) ? ( 24 ) : ( 25 ) ) ) : ( 26 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_12
	

	namespace SubModel_13 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 9 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 10 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 14 ,  {0.0, 0.8888888888888888, 0.05555555555555555, 0.05555555555555555 }} ,
				{ 15 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 18 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 19 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 21 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 24 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 27 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 28 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_4 <= 0.5936837196350098) ? ( (Feature_7 <= 0.362348735332489) ? ( (Feature_1 <= -0.18501364439725876) ? ( (Feature_1 <= -0.7423888742923737) ? ( 4 ) : ( 5 ) ) : ( (Feature_4 <= -0.22707927227020264) ? ( 7 ) : ( (Feature_5 <= 0.1437649130821228) ? ( 9 ) : ( 10 ) ) ) ) : ( (Feature_6 <= -0.42736783623695374) ? ( (Feature_7 <= 3.071837544441223) ? ( (Feature_5 <= 1.7956550121307373) ? ( 14 ) : ( 15 ) ) : ( 16 ) ) : ( (Feature_1 <= -0.28247935324907303) ? ( 18 ) : ( 19 ) ) ) ) : ( (Feature_6 <= -0.843204140663147) ? ( 21 ) : ( (Feature_5 <= 0.20823607966303825) ? ( (Feature_1 <= 1.870528221130371) ? ( 24 ) : ( (Feature_8 <= 1.9057921469211578) ? ( 26 ) : ( 27 ) ) ) : ( 28 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_13
	

	namespace SubModel_14 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 4 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 5 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 12 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 15 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 17 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 20 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 23 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 24 ,  {0.75, 0.25, 0.0, 0.0 }} ,
				{ 26 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 27 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 28 ,  {0.0, 1.0, 0.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_4 <= -0.20330389961600304) ? ( (Feature_7 <= 0.05355269636493176) ? ( (Feature_1 <= -0.18501364439725876) ? ( (Feature_5 <= 0.07402315735816956) ? ( 4 ) : ( 5 ) ) : ( (Feature_5 <= -1.9143248796463013) ? ( 7 ) : ( 8 ) ) ) : ( (Feature_0 <= 0.5461699515581131) ? ( (Feature_9 <= 0.22027607262134552) ? ( (Feature_3 <= 0.5982346087694168) ? ( 12 ) : ( 13 ) ) : ( (Feature_4 <= -1.0224858522415161) ? ( 15 ) : ( 16 ) ) ) : ( 17 ) ) ) : ( (Feature_3 <= 1.5462548732757568) ? ( (Feature_3 <= -2.13624769449234) ? ( 20 ) : ( (Feature_5 <= 0.33322329074144363) ? ( (Feature_1 <= 1.870528221130371) ? ( 23 ) : ( 24 ) ) : ( (Feature_5 <= 1.0488641560077667) ? ( 26 ) : ( 27 ) ) ) ) : ( 28 ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_14
	

	namespace SubModel_15 {
	
		std::vector<std::any> get_classes(){
			std::vector<std::any> lClasses = { 0, 1, 2, 3 };
	
			return lClasses;
		}
	
		typedef std::vector<double> tNodeData;
		std::map<int, tNodeData> Decision_Tree_Node_data = {
				{ 5 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 6 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 7 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 8 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 11 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 12 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 13 ,  {0.0, 0.0, 1.0, 0.0 }} ,
				{ 16 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 18 ,  {1.0, 0.0, 0.0, 0.0 }} ,
				{ 20 ,  {0.0, 1.0, 0.0, 0.0 }} ,
				{ 21 ,  {0.0, 0.8, 0.0, 0.2 }} ,
				{ 23 ,  {0.0, 0.0, 0.0, 1.0 }} ,
				{ 24 ,  {0.0, 0.0, 1.0, 0.0 }} 
		};
		
	
		int get_decision_tree_node_index(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			int lNodeIndex = (Feature_3 <= 1.0540543794631958) ? ( (Feature_4 <= -0.35484130680561066) ? ( (Feature_1 <= 0.8389769792556763) ? ( (Feature_8 <= -0.4956623911857605) ? ( (Feature_1 <= -0.46426843106746674) ? ( 5 ) : ( 6 ) ) : ( 7 ) ) : ( 8 ) ) : ( (Feature_6 <= 1.1597294807434082) ? ( (Feature_2 <= -2.539427638053894) ? ( 11 ) : ( 12 ) ) : ( 13 ) ) ) : ( (Feature_8 <= 1.0354389548301697) ? ( (Feature_7 <= -0.31694556027650833) ? ( 16 ) : ( (Feature_9 <= -1.589853823184967) ? ( 18 ) : ( (Feature_8 <= 0.33265136182308197) ? ( 20 ) : ( 21 ) ) ) ) : ( (Feature_7 <= 0.6524839902995154) ? ( 23 ) : ( 24 ) ) );
		
			return lNodeIndex;
		}
		
	
		std::vector<std::string> get_input_names(){
			std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };
	
			return lFeatures;
		}
	
		std::vector<std::string> get_output_names(){
			std::vector<std::string> lOutputs = { 
				"Score_0", "Score_1", "Score_2", "Score_3",
				"Proba_0", "Proba_1", "Proba_2", "Proba_3",
				"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
				"Decision", "DecisionProba" };
	
			return lOutputs;
		}
	
		tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
			auto lClasses = get_classes();
	
			int lNodeIndex = get_decision_tree_node_index(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9);
	
			std::vector<double> lNodeValue = Decision_Tree_Node_data[ lNodeIndex ];
	
	
			tTable lTable;
	
			lTable["Score"] = { 
				std::any(),
				std::any(),
				std::any(),
				std::any() 
			} ;
			lTable["Proba"] = { 
				lNodeValue [ 0 ],
				lNodeValue [ 1 ],
				lNodeValue [ 2 ],
				lNodeValue [ 3 ] 
			} ;
			int lBestClass = get_arg_max( lTable["Proba"] );
			auto lDecision = lClasses[lBestClass];
			lTable["Decision"] = { lDecision } ;
			lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };
	
			recompute_log_probas( lTable );
	
			return lTable;
		}
	
		tTable compute_model_outputs_from_table( tTable const & iTable) {
			tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);
	
			return lTable;
		}
	
	} // eof namespace SubModel_15
	

	std::vector<std::string> get_input_names(){
		std::vector<std::string> lFeatures = { "Feature_0", "Feature_1", "Feature_2", "Feature_3", "Feature_4", "Feature_5", "Feature_6", "Feature_7", "Feature_8", "Feature_9" };

		return lFeatures;
	}

	std::vector<std::string> get_output_names(){
		std::vector<std::string> lOutputs = { 
			"Score_0", "Score_1", "Score_2", "Score_3",
			"Proba_0", "Proba_1", "Proba_2", "Proba_3",
			"LogProba_0", "LogProba_1", "LogProba_2", "LogProba_3",
			"Decision", "DecisionProba" };

		return lOutputs;
	}

	tTable compute_classification_scores(std::any Feature_0, std::any Feature_1, std::any Feature_2, std::any Feature_3, std::any Feature_4, std::any Feature_5, std::any Feature_6, std::any Feature_7, std::any Feature_8, std::any Feature_9) {
		auto lClasses = get_classes();

		std::vector<tTable> lTreeScores = { 
			SubModel_0::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_1::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_2::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_3::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_4::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_5::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_6::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_7::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_8::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_9::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_10::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_11::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_12::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_13::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_14::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9),
			SubModel_15::compute_classification_scores(Feature_0, Feature_1, Feature_2, Feature_3, Feature_4, Feature_5, Feature_6, Feature_7, Feature_8, Feature_9)
		};

		tTable lAggregatedTable = aggregate_bag_scores(lTreeScores, {"Proba", "Score"});


		tTable lTable = lAggregatedTable;

		int lBestClass = get_arg_max( lTable["Proba"] );
		auto lDecision = lClasses[lBestClass];
		lTable["Decision"] = { lDecision } ;
		lTable["DecisionProba"] = { lTable["Proba"][lBestClass] };

		recompute_log_probas( lTable );

		return lTable;
	}

	tTable compute_model_outputs_from_table( tTable const & iTable) {
		tTable lTable = compute_classification_scores(iTable.at("Feature_0")[0], iTable.at("Feature_1")[0], iTable.at("Feature_2")[0], iTable.at("Feature_3")[0], iTable.at("Feature_4")[0], iTable.at("Feature_5")[0], iTable.at("Feature_6")[0], iTable.at("Feature_7")[0], iTable.at("Feature_8")[0], iTable.at("Feature_9")[0]);

		return lTable;
	}

} // eof namespace 


int main() {
	score_csv_file("outputs/ml2cpp-demo/datasets/FourClass_10.csv");
	return 0;
}
